import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import { BattleEngine, BattleConfig, BattleState } from '@/lib/battleEngine';

/**
 * Feature: star-wars-landing-page, Property 1: Battle Scene Faction Presence
 *
 * For any battle state generated by the BattleEngine, the state SHALL contain
 * at least one starship from each faction (rebel and imperial), ensuring both
 * sides are always represented in the combat scene.
 *
 * **Validates: Requirements 1.2**
 */

// Smart generator for valid BattleConfig overrides
const battleConfigArb = fc.record({
  canvasWidth: fc.integer({ min: 200, max: 4000 }),
  canvasHeight: fc.integer({ min: 200, max: 4000 }),
  rebelShipCount: fc.integer({ min: 1, max: 20 }),
  imperialShipCount: fc.integer({ min: 1, max: 20 }),
  shipSpeed: fc.integer({ min: 10, max: 500 }),
  projectileSpeed: fc.integer({ min: 50, max: 1000 }),
  fireRate: fc.integer({ min: 100, max: 10000 }),
  projectileDamage: fc.integer({ min: 1, max: 100 }),
  explosionDuration: fc.integer({ min: 100, max: 2000 }),
  respawnDelay: fc.integer({ min: 100, max: 10000 }),
}) satisfies fc.Arbitrary<BattleConfig>;

// Generator for a sequence of update delta times (in seconds)
const updateSequenceArb = fc.array(
  fc.double({ min: 0.001, max: 0.1, noNaN: true }),
  { minLength: 0, maxLength: 50 }
);

describe('BattleEngine - Property 1: Battle Scene Faction Presence', () => {
  /**
   * **Validates: Requirements 1.2**
   *
   * After construction with any valid config, the battle state must contain
   * at least one alive ship from each faction.
   */
  it('should have at least one alive ship from each faction after construction', () => {
    fc.assert(
      fc.property(battleConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const state = engine.getState();

        const aliveRebels = state.ships.filter(
          (s) => s.faction === 'rebel' && s.health > 0
        );
        const aliveImperials = state.ships.filter(
          (s) => s.faction === 'imperial' && s.health > 0
        );

        expect(aliveRebels.length).toBeGreaterThanOrEqual(1);
        expect(aliveImperials.length).toBeGreaterThanOrEqual(1);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.2**
   *
   * After any number of update cycles with various delta times, the battle
   * state must still contain at least one alive ship from each faction.
   * The respawn mechanism ensures both factions are always represented.
   */
  it('should maintain at least one alive ship from each faction after multiple updates', () => {
    fc.assert(
      fc.property(battleConfigArb, updateSequenceArb, (config, deltas) => {
        const engine = new BattleEngine(config);

        // Run through all the update steps
        for (const dt of deltas) {
          engine.update(dt);
        }

        const state = engine.getState();

        // Count alive ships per faction
        const aliveRebels = state.ships.filter(
          (s) => s.faction === 'rebel' && s.health > 0
        );
        const aliveImperials = state.ships.filter(
          (s) => s.faction === 'imperial' && s.health > 0
        );

        // At least one alive ship from each faction must exist
        // (dead ships awaiting respawn may also be present, but at least one must be alive)
        expect(aliveRebels.length).toBeGreaterThanOrEqual(1);
        expect(aliveImperials.length).toBeGreaterThanOrEqual(1);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.2**
   *
   * After reset, the battle state must again contain at least one alive ship
   * from each faction, regardless of what happened before the reset.
   */
  it('should have both factions present after reset', () => {
    fc.assert(
      fc.property(battleConfigArb, updateSequenceArb, (config, deltas) => {
        const engine = new BattleEngine(config);

        // Run some updates
        for (const dt of deltas) {
          engine.update(dt);
        }

        // Reset and verify
        engine.reset();
        const state = engine.getState();

        const aliveRebels = state.ships.filter(
          (s) => s.faction === 'rebel' && s.health > 0
        );
        const aliveImperials = state.ships.filter(
          (s) => s.faction === 'imperial' && s.health > 0
        );

        expect(aliveRebels.length).toBeGreaterThanOrEqual(1);
        expect(aliveImperials.length).toBeGreaterThanOrEqual(1);
      }),
      { numRuns: 100 }
    );
  });
});


/**
 * Feature: star-wars-landing-page, Property 2: Firing Creates Projectiles
 *
 * For any starship that executes a fire action toward a valid target, the
 * BattleEngine SHALL create exactly one new LaserProjectile with the correct
 * origin position (firing ship's position), target ID, and faction matching
 * the firing ship.
 *
 * **Validates: Requirements 1.4**
 */

// Generator for a valid battle config with at least 1 ship per faction
const firingBattleConfigArb = fc.record({
  canvasWidth: fc.integer({ min: 400, max: 4000 }),
  canvasHeight: fc.integer({ min: 400, max: 4000 }),
  rebelShipCount: fc.integer({ min: 1, max: 10 }),
  imperialShipCount: fc.integer({ min: 1, max: 10 }),
  shipSpeed: fc.integer({ min: 10, max: 500 }),
  projectileSpeed: fc.integer({ min: 50, max: 1000 }),
  fireRate: fc.integer({ min: 100, max: 10000 }),
  projectileDamage: fc.integer({ min: 1, max: 50 }),
  explosionDuration: fc.integer({ min: 100, max: 2000 }),
  respawnDelay: fc.integer({ min: 100, max: 10000 }),
}) satisfies fc.Arbitrary<BattleConfig>;

describe('BattleEngine - Property 2: Firing Creates Projectiles', () => {
  /**
   * **Validates: Requirements 1.4**
   *
   * When fireAtTarget is called with valid ship and target IDs (alive ships
   * of different factions), exactly one new projectile is created with the
   * correct origin position, targetId, and faction.
   */
  it('should create exactly one projectile with correct origin, targetId, and faction when firing', () => {
    fc.assert(
      fc.property(firingBattleConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const state = engine.getState();

        // Pick a random alive ship and a random alive enemy target
        const aliveShips = state.ships.filter((s) => s.health > 0);
        const rebels = aliveShips.filter((s) => s.faction === 'rebel');
        const imperials = aliveShips.filter((s) => s.faction === 'imperial');

        // We need at least one from each faction
        if (rebels.length === 0 || imperials.length === 0) return;

        // Pick a rebel as the firing ship and an imperial as the target
        const firingShip = rebels[0];
        const targetShip = imperials[0];

        // Record projectile count before firing
        const projectilesBefore = engine.getState().projectiles.length;

        // Record the firing ship's position before firing
        const originX = firingShip.x;
        const originY = firingShip.y;

        // Fire
        engine.fireAtTarget(firingShip.id, targetShip.id);

        // Get state after firing
        const stateAfter = engine.getState();

        // Exactly one new projectile should have been created
        expect(stateAfter.projectiles.length).toBe(projectilesBefore + 1);

        // The new projectile is the last one added
        const newProjectile = stateAfter.projectiles[stateAfter.projectiles.length - 1];

        // Projectile origin should match the firing ship's position
        expect(newProjectile.x).toBe(originX);
        expect(newProjectile.y).toBe(originY);

        // Projectile targetId should match the target ship's id
        expect(newProjectile.targetId).toBe(targetShip.id);

        // Projectile faction should match the firing ship's faction
        expect(newProjectile.faction).toBe(firingShip.faction);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.4**
   *
   * When an imperial ship fires at a rebel target, the projectile should
   * also have the correct properties (testing the reverse direction).
   */
  it('should create correct projectile when imperial fires at rebel', () => {
    fc.assert(
      fc.property(firingBattleConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const state = engine.getState();

        const aliveShips = state.ships.filter((s) => s.health > 0);
        const rebels = aliveShips.filter((s) => s.faction === 'rebel');
        const imperials = aliveShips.filter((s) => s.faction === 'imperial');

        if (rebels.length === 0 || imperials.length === 0) return;

        // Imperial fires at rebel (reverse direction)
        const firingShip = imperials[0];
        const targetShip = rebels[0];

        const projectilesBefore = engine.getState().projectiles.length;
        const originX = firingShip.x;
        const originY = firingShip.y;

        engine.fireAtTarget(firingShip.id, targetShip.id);

        const stateAfter = engine.getState();

        expect(stateAfter.projectiles.length).toBe(projectilesBefore + 1);

        const newProjectile = stateAfter.projectiles[stateAfter.projectiles.length - 1];
        expect(newProjectile.x).toBe(originX);
        expect(newProjectile.y).toBe(originY);
        expect(newProjectile.targetId).toBe(targetShip.id);
        expect(newProjectile.faction).toBe('imperial');
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.4**
   *
   * Multiple sequential fires should each create exactly one projectile,
   * and each projectile should have the correct properties for its respective
   * firing ship.
   */
  it('should create one projectile per fire call with correct properties for each', () => {
    fc.assert(
      fc.property(
        firingBattleConfigArb,
        fc.integer({ min: 1, max: 10 }),
        (config, fireCount) => {
          const engine = new BattleEngine(config);
          const state = engine.getState();

          const aliveShips = state.ships.filter((s) => s.health > 0);
          const rebels = aliveShips.filter((s) => s.faction === 'rebel');
          const imperials = aliveShips.filter((s) => s.faction === 'imperial');

          if (rebels.length === 0 || imperials.length === 0) return;

          const initialProjectileCount = engine.getState().projectiles.length;

          // Fire multiple times from different ships
          for (let i = 0; i < fireCount; i++) {
            const firingShip = rebels[i % rebels.length];
            const targetShip = imperials[i % imperials.length];

            const stateBefore = engine.getState();
            const countBefore = stateBefore.projectiles.length;

            engine.fireAtTarget(firingShip.id, targetShip.id);

            const stateAfterFire = engine.getState();
            // Each fire should add exactly one projectile
            expect(stateAfterFire.projectiles.length).toBe(countBefore + 1);

            const newProj = stateAfterFire.projectiles[stateAfterFire.projectiles.length - 1];
            expect(newProj.faction).toBe(firingShip.faction);
            expect(newProj.targetId).toBe(targetShip.id);
          }

          // Total projectiles should equal initial + fireCount
          const finalState = engine.getState();
          expect(finalState.projectiles.length).toBe(initialProjectileCount + fireCount);
        }
      ),
      { numRuns: 100 }
    );
  });
});


/**
 * Feature: star-wars-landing-page, Property 3: Collision Creates Explosion
 *
 * For any LaserProjectile that collides with a Starship (projectile position
 * within ship's hitbox), the BattleEngine SHALL create exactly one Explosion
 * entity at the collision point and reduce the target ship's health by the
 * projectile's damage value.
 *
 * **Validates: Requirements 1.5**
 */

// Generator for collision-focused config:
// - shipSpeed = 0 so ships are stationary and projectile trajectory is predictable
// - Very high fireRate so autoFire never triggers additional projectiles during the test
// - Long explosionDuration so explosions persist and can be observed after collision
// - Long respawnDelay so destroyed ships stay dead during the test
const collisionConfigArb = fc.record({
  canvasWidth: fc.integer({ min: 300, max: 800 }),
  canvasHeight: fc.integer({ min: 300, max: 800 }),
  rebelShipCount: fc.constant(1),
  imperialShipCount: fc.constant(1),
  shipSpeed: fc.constant(0),
  projectileSpeed: fc.integer({ min: 500, max: 2000 }),
  fireRate: fc.constant(999999), // Prevent autoFire from creating extra projectiles
  projectileDamage: fc.integer({ min: 1, max: 99 }), // Keep < 100 so ship survives first hit
  explosionDuration: fc.constant(60000), // Very long so explosions persist
  respawnDelay: fc.constant(60000),
}) satisfies fc.Arbitrary<BattleConfig>;

describe('BattleEngine - Property 3: Collision Creates Explosion', () => {
  /**
   * **Validates: Requirements 1.5**
   *
   * When a projectile collides with an enemy ship, exactly one explosion is
   * created at the collision point, the ship's health is reduced by the
   * projectile's damage value, and the projectile is removed.
   */
  it('should create an explosion, reduce ship health, and remove projectile on collision', () => {
    fc.assert(
      fc.property(collisionConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const initialState = engine.getState();

        // Find the rebel and imperial ships
        const rebel = initialState.ships.find((s) => s.faction === 'rebel' && s.health > 0);
        const imperial = initialState.ships.find((s) => s.faction === 'imperial' && s.health > 0);

        expect(rebel).toBeDefined();
        expect(imperial).toBeDefined();
        if (!rebel || !imperial) return;

        // Record initial health of the target (imperial)
        const initialHealth = imperial.health;

        // No explosions or projectiles initially
        expect(initialState.explosions.length).toBe(0);
        expect(initialState.projectiles.length).toBe(0);

        // Fire a projectile from rebel at imperial
        engine.fireAtTarget(rebel.id, imperial.id);

        // Verify projectile was created
        const stateAfterFire = engine.getState();
        expect(stateAfterFire.projectiles.length).toBe(1);
        const firedProjectileId = stateAfterFire.projectiles[0].id;

        // Calculate the distance between the two ships
        const dx = imperial.x - rebel.x;
        const dy = imperial.y - rebel.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate time for projectile to reach the target
        const timeToReach = distance / config.projectileSpeed;

        // Advance the simulation in small steps to ensure the collision is detected
        const steps = 300;
        const stepDelta = (timeToReach * 1.5) / steps;
        let collisionDetected = false;

        for (let i = 0; i < steps; i++) {
          engine.update(stepDelta);

          const currentState = engine.getState();
          const ourProjectile = currentState.projectiles.find((p) => p.id === firedProjectileId);

          // Collision happened when our specific projectile is removed
          if (!ourProjectile) {
            collisionDetected = true;
            break;
          }
        }

        expect(collisionDetected).toBe(true);

        // Verify the results after collision
        const finalState = engine.getState();

        // The fired projectile should have been removed
        expect(finalState.projectiles.find((p) => p.id === firedProjectileId)).toBeUndefined();

        // At least one explosion should have been created
        expect(finalState.explosions.length).toBeGreaterThanOrEqual(1);

        // The target ship's health should have been reduced by projectileDamage
        const targetShipAfter = finalState.ships.find((s) => s.id === imperial.id);
        expect(targetShipAfter).toBeDefined();
        if (targetShipAfter) {
          expect(targetShipAfter.health).toBe(initialHealth - config.projectileDamage);
        }
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.5**
   *
   * The explosion created on collision should be positioned at the collision
   * point (the projectile's position at the time of collision), which is
   * within the target ship's hitbox radius.
   */
  it('should create explosion at a point within the target ship hitbox', () => {
    fc.assert(
      fc.property(collisionConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const initialState = engine.getState();

        const rebel = initialState.ships.find((s) => s.faction === 'rebel' && s.health > 0);
        const imperial = initialState.ships.find((s) => s.faction === 'imperial' && s.health > 0);

        if (!rebel || !imperial) return;

        // Fire from rebel at imperial
        engine.fireAtTarget(rebel.id, imperial.id);
        const firedProjectileId = engine.getState().projectiles[0].id;

        // Advance simulation until collision
        const dx = imperial.x - rebel.x;
        const dy = imperial.y - rebel.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const timeToReach = distance / config.projectileSpeed;

        const steps = 300;
        const stepDelta = (timeToReach * 1.5) / steps;
        let explosionState: BattleState | null = null;

        for (let i = 0; i < steps; i++) {
          const stateBefore = engine.getState();
          const hadProjectile = stateBefore.projectiles.some((p) => p.id === firedProjectileId);

          engine.update(stepDelta);

          const stateAfter = engine.getState();
          const hasProjectile = stateAfter.projectiles.some((p) => p.id === firedProjectileId);

          // Detect the exact moment our projectile is removed (collision happened)
          if (hadProjectile && !hasProjectile) {
            explosionState = stateAfter;
            break;
          }
        }

        expect(explosionState).not.toBeNull();
        if (!explosionState) return;

        // The first explosion should be near the target ship's position
        const explosion = explosionState.explosions[0];
        const targetShip = explosionState.ships.find((s) => s.id === imperial.id);
        expect(targetShip).toBeDefined();
        if (!targetShip) return;

        // The explosion position should be within the ship's size (hitbox radius)
        // plus a tolerance for the projectile's movement within one simulation step
        const explosionDx = explosion.x - targetShip.x;
        const explosionDy = explosion.y - targetShip.y;
        const explosionDist = Math.sqrt(explosionDx * explosionDx + explosionDy * explosionDy);

        const maxStepMovement = config.projectileSpeed * stepDelta;
        expect(explosionDist).toBeLessThanOrEqual(targetShip.size + maxStepMovement);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * **Validates: Requirements 1.5**
   *
   * When a projectile collides with a ship and reduces its health to zero,
   * the ship should be destroyed (health = 0) and an additional explosion
   * should be created at the ship's position.
   */
  it('should create additional explosion when ship is destroyed by collision', () => {
    // Use damage = 100 to guarantee one-hit kill (ships start with 100 health)
    const destroyConfigArb = fc.record({
      canvasWidth: fc.integer({ min: 300, max: 800 }),
      canvasHeight: fc.integer({ min: 300, max: 800 }),
      rebelShipCount: fc.constant(1),
      imperialShipCount: fc.constant(1),
      shipSpeed: fc.constant(0),
      projectileSpeed: fc.integer({ min: 500, max: 2000 }),
      fireRate: fc.constant(999999), // Prevent autoFire
      projectileDamage: fc.constant(100), // One-hit kill
      explosionDuration: fc.constant(60000), // Very long so explosions persist
      respawnDelay: fc.constant(60000),
    }) satisfies fc.Arbitrary<BattleConfig>;

    fc.assert(
      fc.property(destroyConfigArb, (config) => {
        const engine = new BattleEngine(config);
        const initialState = engine.getState();

        const rebel = initialState.ships.find((s) => s.faction === 'rebel' && s.health > 0);
        const imperial = initialState.ships.find((s) => s.faction === 'imperial' && s.health > 0);

        if (!rebel || !imperial) return;

        // Fire from rebel at imperial
        engine.fireAtTarget(rebel.id, imperial.id);
        const firedProjectileId = engine.getState().projectiles[0].id;

        // Advance simulation until collision
        const dx = imperial.x - rebel.x;
        const dy = imperial.y - rebel.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const timeToReach = distance / config.projectileSpeed;

        const steps = 300;
        const stepDelta = (timeToReach * 1.5) / steps;
        let collisionDetected = false;

        for (let i = 0; i < steps; i++) {
          const stateBefore = engine.getState();
          const hadProjectile = stateBefore.projectiles.some((p) => p.id === firedProjectileId);

          engine.update(stepDelta);

          const stateAfter = engine.getState();
          const hasProjectile = stateAfter.projectiles.some((p) => p.id === firedProjectileId);

          if (hadProjectile && !hasProjectile) {
            collisionDetected = true;
            break;
          }
        }

        expect(collisionDetected).toBe(true);

        const finalState = engine.getState();

        // Ship should be destroyed (health = 0)
        const targetShipAfter = finalState.ships.find((s) => s.id === imperial.id);
        expect(targetShipAfter).toBeDefined();
        if (targetShipAfter) {
          expect(targetShipAfter.health).toBe(0);
        }

        // Two explosions should be created: one at collision point, one at ship position
        expect(finalState.explosions.length).toBe(2);
      }),
      { numRuns: 100 }
    );
  });
});
